use std::{collections::HashMap, env, error::Error, fs, path::PathBuf};

use serde::Deserialize;

use crate::{collect_project_config, template::template, Project};

use super::parse_args::SkelArgs;

pub type SkelResult<T> = Result<T, Box<dyn Error>>;
pub type UserConfigResult = SkelResult<UserConfig>;

#[derive(Debug, Deserialize)]
pub struct UserConfig {
    pub projects: HashMap<String, String>,
    pub alias: HashMap<String, Vec<String>>,
}

fn make_config_from_toml(config_path: &PathBuf) -> UserConfigResult {
    use std::io::Read;

    if !config_path.exists() {
        return Err(Box::from(format!(
            "config dose not exists -- {}",
            config_path.to_str().expect("cant get root path"),
        )));
    }

    let mut conf_file =
        fs::File::open(&config_path).expect("cant open config file");

    let mut config_str = String::new();

    conf_file
        .read_to_string(&mut config_str)
        .expect("cant read config file to string");

    // TODO: let the user know whats wrong in a nice way
    // idk, maybe just say bad config with the file name
    let toml_conf = toml::from_str::<UserConfig>(&config_str)
        .expect(&format!("TOML Error -- {}", config_str));

    Ok(toml_conf)
}

// TODO: make the path delimiter and config name variables
fn config_string_default() -> (PathBuf, PathBuf) {
    let mut config_dir = env::var("HOME")
        .expect("home not set")
        .parse::<PathBuf>()
        .expect("cant make path buf from config string");

    // first make the directory
    config_dir.push(".config");
    config_dir.push("skel");

    // then the actual file
    let mut config_file = config_dir.clone();
    config_file.push("config.toml");

    (config_file, config_dir)
}

fn collect_user_config() -> SkelResult<(UserConfig, PathBuf)> {
    let (config_path, config_dir) = config_string_default();

    let conf = make_config_from_toml(&config_path)?;

    Ok((conf, config_dir))
}

fn resolve_user_config(
    type_str: &str,
    project_file: Option<&String>,
) -> Result<(PathBuf, PathBuf), Box<dyn Error>> {
    match project_file {
        Some(project_file) => {
            let (_, config_dir_path) = config_string_default();

            Ok((PathBuf::from(project_file), config_dir_path))
        }
        None => {
            let (user_config, config_dir_path) = collect_user_config()?;

            let project_config_path = project_path_with_templateing(
                type_str,
                &user_config,
                config_dir_path
                    .to_str()
                    .as_ref()
                    .expect("cant get config path str"),
            )?;

            Ok((project_config_path, config_dir_path))
        }
    }
}

fn find_project_file(
    user_config: &UserConfig,
    type_str: &str,
) -> SkelResult<String> {
    let type_string = type_str.to_string();

    if let Some(path_string) = user_config.projects.get(&type_string) {
        return Ok(path_string.clone());
    }

    let mut project_string = String::new();

    for (project, alias) in user_config.alias.iter() {
        if alias.contains(&type_string) {
            project_string.clone_from(project);
            break;
        }
    }

    if project_string.is_empty() {
        return Err(Box::from(format!(
            "given project type not in user config -- {}",
            type_str
        )));
    }

    match user_config.projects.get(&project_string) {
        Some(val) => Ok(val.to_string()),
        None => Err(Box::from(format!(
            "no project for that alias -- {}",
            type_string
        ))),
    }
}

fn project_path_with_templateing(
    type_str: &str,
    user_config: &UserConfig,
    config_dir: &str,
) -> SkelResult<PathBuf> {
    let p_string = find_project_file(user_config, type_str)?;

    // this is lame but the only place empty string are used
    let p_string = template("", "", &config_dir, &p_string);

    Ok(PathBuf::from(p_string))
}

fn resolve_project_root(name: &str, root_from_cli: &Option<String>) -> String {
    let mut r_string = if let Some(from_cli) = root_from_cli {
        from_cli.to_owned()
    } else {
        // default to current_dir
        env::current_dir()
            .expect("cant get current_dir")
            .to_str()
            .expect("cant get str from current dir")
            .to_owned()
    };

    // set root to the project name not the current_dir
    // or the one given on the cli
    // TODO: make this generic for windows maybe
    r_string.push('/');
    r_string.push_str(name);

    r_string
}

// last takes precedent:
//      default > config > cli config
pub fn resolve_default(args: SkelArgs) -> SkelResult<Project> {
    let (config_pathbuf, config_dir_path) =
        resolve_user_config(&args.type_str, args.cli_project_file.as_ref())?;

    let mut file_config = collect_project_config(&config_pathbuf)?;
    let root_string = resolve_project_root(&args.name, &args.different_root);

    file_config.resolve_project_templates(
        &root_string,
        &args.name,
        config_dir_path
            .to_str()
            .as_ref()
            .expect("cant unwrap config_dir_path"),
    )?;

    if file_config.files.is_none()
        && file_config.dirs.is_none()
        && file_config.build.is_none()
    {
        return Err(Box::from("project dose not have anything to do"));
    }

    let build_first = if args.build_first
        || (file_config.build_first.is_some()
            && file_config.build_first.unwrap())
    {
        true
    } else {
        false
    };

    let project = Project {
        build_first,
        dirs: file_config.dirs,
        files: file_config.files,
        build: file_config.build,
        templates: file_config.templates,
        config_dir_string: config_dir_path,
        name: args.name,
        project_root_path: PathBuf::from(&root_string),
        project_root_string: root_string,
        dont_make_template: args.dont_make_templates,
        dont_run_build: args.dont_run_build,
        show_build_output: args.show_build_output,
    };

    Ok(project)
}

#[cfg(test)]
mod test {
    use super::*;

    use crate::test_utils::{make_fake_user_config, TempSetup};

    #[test]
    fn test_config_string_default_or_default() {
        let (test_config_path, test_config_dir) = config_string_default();

        let mut config_dir = env::var("HOME")
            .expect("HOME not set")
            .parse::<PathBuf>()
            .unwrap();

        // first make the directory
        config_dir.push(".config");
        config_dir.push("skel");

        // then the actual file
        let mut config_file = config_dir.clone();
        config_file.push('/');
        config_file.push_str("config.toml");

        assert_eq!(
            test_config_dir, config_dir,
            "config_string_default_or did not make dir right"
        );

        assert_eq!(
            test_config_path, config_file,
            "did not make config_dir_path right"
        );
    }

    #[test]
    fn test_find_project_file() {
        let config = make_fake_user_config();

        let project = find_project_file(&config, "cp");

        assert!(project.is_ok(), "failed to find project to make");

        assert_eq!(
            project.unwrap(),
            String::from("{{config-dir}}/projects/basic_cpp.toml"),
            "failed to find project to make"
        );

        let project = find_project_file(&config, "p");

        assert!(project.is_ok(), "failed to find project to make");

        assert_eq!(
            project.unwrap(),
            String::from("{{config-dir}}/projects/basic_python.toml"),
            "failed to find project to make"
        );

        let project = find_project_file(&config, "basic_javascript");

        assert!(project.is_ok(), "failed to find project to make");

        assert_eq!(
            project.unwrap(),
            String::from("{{config-dir}}/projects/basic_javascript.toml"),
            "failed to find project to make"
        );
    }

    #[test]
    fn test_project_path_with_templateing() {
        let fake_config_dir = String::from("/tmp/skel");

        let conf = make_fake_user_config();

        let project_path = match project_path_with_templateing(
            "cp",
            &conf,
            &fake_config_dir,
        ) {
            Err(err) => {
                assert!(false, "{}", err);
                // or just return
                unreachable!();
            }
            Ok(val) => val,
        };

        assert_eq!(
            project_path,
            PathBuf::from("/tmp/skel/projects/basic_cpp.toml"),
            "failed to template path"
        );
    }

    #[test]
    fn test_make_config_from_toml() {
        let mut temp = TempSetup::default();
        let root = temp.setup();

        let mut temp_config = root.clone();

        temp_config.push(".config");
        temp_config.push("skel");
        temp_config.push("config.toml");

        temp.make_fake_user_config().expect("cant make user config");

        let user_config = match make_config_from_toml(
            temp_config.to_str().expect("cant get config path"),
        ) {
            Err(err) => {
                assert!(false, "{}", err);
                unreachable!();
            }
            Ok(val) => val,
        };

        let mut projects: HashMap<String, String> = HashMap::new();

        projects.insert(
            String::from("basic_python"),
            String::from("{{config-dir}}/projects/basic_python.toml"),
        );
        projects.insert(
            String::from("basic_cpp"),
            String::from("{{config-dir}}/projects/basic_cpp.toml"),
        );
        projects.insert(
            String::from("basic_javascript"),
            String::from("{{config-dir}}/projects/basic_javascript.toml"),
        );

        assert_eq!(
            user_config.projects, projects,
            "failsed to make user config projects"
        );

        let mut alias: HashMap<String, Vec<String>> = HashMap::new();

        alias.insert(
            String::from("basic_cpp"),
            vec![String::from("cpp"), String::from("cp"), String::from("c++")],
        );

        alias.insert(
            String::from("basic_python"),
            vec![String::from("py"), String::from("p")],
        );

        alias.insert(
            String::from("basic_javascript"),
            vec![String::from("js"), String::from("j")],
        );

        assert_eq!(
            user_config.alias, alias,
            "failed to make user config alias's"
        );
    }

    #[test]
    fn test_resolve_user_config_no_user_path() {
        let mut temp = TempSetup::default();
        let root = temp.setup();

        let fake_home = root.to_str().unwrap();
        env::set_var("HOME", fake_home);

        temp.make_fake_user_config()
            .expect("did not make fake config");

        let type_str = "cpp";
        let user_path = None;

        let mut fake_config = fake_home.to_string();

        fake_config.push_str("/.config/skel");

        let mut fake_config_file = fake_config.to_string();

        fake_config_file.push_str("/projects/basic_cpp.toml");

        match resolve_user_config(type_str, user_path) {
            Ok((proj_path, proj_dir)) => {
                assert_eq!(
                    proj_path,
                    PathBuf::from(fake_config_file),
                    "did not find c++ toml file"
                );

                assert_eq!(
                    proj_dir, fake_config,
                    "did not make proj_dir right"
                );
            }
            Err(err) => assert!(false, "Error: {}", err),
        };
    }

    #[test]
    fn test_resolve_user_config_user_path_provided() {
        let type_str = "cpp";

        let user_path_str = String::from("/tmp/skel/projects/cpp.toml");

        env::set_var("HOME", "/home/test");

        match resolve_user_config(type_str, Some(&user_path_str)) {
            Ok((proj_path, proj_dir)) => {
                assert_eq!(
                    proj_path,
                    PathBuf::from("/tmp/skel/projects/cpp.toml"),
                    "did not find c++ toml file"
                );

                assert_eq!(
                    proj_dir, "/home/test/.config/skel",
                    "did not make proj_dir right"
                );
            }
            Err(err) => assert!(false, "Error: {}", err),
        };
    }
}
